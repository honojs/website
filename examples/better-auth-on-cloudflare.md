# Better Auth on Cloudflare

A TypeScript-based lightweight authentication service optimized for Cloudflare Workers

## Stack Summary

**🔥 [Hono](https://hono.dev)**  
A fast, lightweight web framework built on web standards.

**🔒 [Better Auth](https://www.better-auth.com)**  
A comprehensive authentication framework for TypeScript.

**🧩 [Drizzle ORM](https://orm.drizzle.team)**  
A lightweight, high-performance ORM for TypeScript, built with DX in mind.

**🐘 [Postgres with Neon](https://neon.tech)**  
A serverless Postgres optimized for the cloud.

## Preparation

### 1. Installation

```sh [pnpm]
# Hono
# > Select cloudflare-workers template
pnpm create hono

# Better Auth
pnpm add better-auth

# Drizzle ORM
pnpm add drizzle-orm
pnpm add -D drizzle-kit

# Neon
pnpm add @neondatabase/serverless
```

### 2. Environment Variables

Set the following environment variables to connect this application to Better Auth and Neon.

Refer to official guides:

- [Better Auth – Guide](https://www.better-auth.com/docs/installation#set-environment-variables)
- [Neon – Guide](https://neon.tech/docs/connect/connect-from-any-app)

**Required Files:**

::: code-group

```Plain Text[.dev.vars]
# Used by Wrangler in local development
# In production, these should be set as Cloudflare Worker Secrets.

BETTER_AUTH_URL=
BETTER_AUTH_SECRET=
DATABASE_URL=
```

```Plain Text[.env]
# Used for local development and CLI tools such as:
#
# - Drizzle ORM (drizzle-kit)
# - Better Auth CLI

BETTER_AUTH_URL=
BETTER_AUTH_SECRET=
DATABASE_URL=
```

:::

### 3. Wrangler

After setting your environment variables, run the following script to generate types for your Cloudflare Workers configuration:

```sh
pnpm cf-typegen

# or

pnpm wrangler types --env-interface CloudflareBindings

```

Then, make sure your tsconfig.json includes the generated types

```json[tsconfig.json]
{
  "compilerOptions": {
    "types": ["worker-configuration.d.ts"]
  }
}
```

### 4. Drizzle

To use the Drizzle Kit CLI, add the following Drizzle configuration file to the root of your project.

```ts[drizzle.config.ts]
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  out: './drizzle',
  schema: './src/db/schemas/*',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

## Application

### 1. Better Auth Instance

Create a Better Auth instance using Cloudflare Workers bindings.

There are many available configuration options, far more than can be covered in this example.
Please refer to the official documentation and configure it according to your project’s needs:

(Docs: [Better Auth - Options](https://www.better-auth.com/docs/reference/options))

```ts[src/lib/better-auth.ts]
import * as authSchema from '../db/schemas/auth';
import { betterAuth } from 'better-auth';
import { neon } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';
import { drizzleAdapter } from 'better-auth/adapters/drizzle';

export const auth = (env: CloudflareBindings) => {
  const sql = neon(env.DATABASE_URL);
  const db = drizzle(sql, { schema: { ...authSchema } });

  return betterAuth({
    appName: 'your-app-name',
    basePath: '/',
    baseURL: env.BETTER_AUTH_URL,
    secret: env.BETTER_AUTH_SECRET,

    database: drizzleAdapter(db, {
      provider: 'pg',
      schema: {
        user: authSchema.user,
        session: authSchema.session,
        account: authSchema.account,
        verification: authSchema.verification,
      },
    }),
  });
};

```

### 2. Auth Schema

Better Auth requires a set of core database tables.
This example connects those tables to a Neon Postgres using Drizzle ORM.

The schema used in this example matches the one generated by Better Auth,
so you can either copy it directly or follow the CLI guide to generate it yourself.

(Docs: [Better Auth - Generating Schema](https://www.better-auth.com/docs/concepts/database#generating-schema))

```ts[src/db/schemas/auth.ts]
import { text, timestamp, boolean, pgSchema } from 'drizzle-orm/pg-core';

const authSchema = pgSchema('auth');

export const user = authSchema.table('user', {
  id: text('id').primaryKey(),
  name: text('name').notNull(),
  email: text('email').notNull().unique(),
  emailVerified: boolean('email_verified')
    .$defaultFn(() => false)
    .notNull(),
  image: text('image'),
  createdAt: timestamp('created_at')
    .$defaultFn(() => /* @__PURE__ */ new Date())
    .notNull(),
  updatedAt: timestamp('updated_at')
    .$defaultFn(() => /* @__PURE__ */ new Date())
    .notNull(),
});

export const session = authSchema.table('session', {
  id: text('id').primaryKey(),
  expiresAt: timestamp('expires_at').notNull(),
  token: text('token').notNull().unique(),
  createdAt: timestamp('created_at').notNull(),
  updatedAt: timestamp('updated_at').notNull(),
  ipAddress: text('ip_address'),
  userAgent: text('user_agent'),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
});

export const account = authSchema.table('account', {
  id: text('id').primaryKey(),
  accountId: text('account_id').notNull(),
  providerId: text('provider_id').notNull(),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  accessToken: text('access_token'),
  refreshToken: text('refresh_token'),
  idToken: text('id_token'),
  accessTokenExpiresAt: timestamp('access_token_expires_at'),
  refreshTokenExpiresAt: timestamp('refresh_token_expires_at'),
  scope: text('scope'),
  password: text('password'),
  createdAt: timestamp('created_at').notNull(),
  updatedAt: timestamp('updated_at').notNull(),
});

export const verification = authSchema.table('verification', {
  id: text('id').primaryKey(),
  identifier: text('identifier').notNull(),
  value: text('value').notNull(),
  expiresAt: timestamp('expires_at').notNull(),
  createdAt: timestamp('created_at').$defaultFn(() => /* @__PURE__ */ new Date()),
  updatedAt: timestamp('updated_at').$defaultFn(() => /* @__PURE__ */ new Date()),
});
```

### 3. Handler Mounting

Mount the Better Auth handler to a Hono endpoint, ensuring that the mount path matches the `basePath` setting in your Better Auth instance.

```ts[src/index.ts]
import { Hono } from 'hono';
import { auth } from './lib/better-auth';

const app = new Hono<{ Bindings: CloudflareBindings }>();

app.on(['GET', 'POST'], '/**', (c) => {
  return auth(c.env).handler(c.req.raw);
});

export default app;
```

## In closing

You now have a lightweight, fast, and comprehensive authentication service running on Cloudflare Workers. By leveraging Service Bindings, you can build a microservice architecture, including authentication, with minimal latency.

However, this is just a **very simple example**. Be sure to read the official documentation and adapt the implementation to fit your service’s specific needs.

You can find the full example code here:  
[Github Repository](https://github.com/bytaesu/cloudflare-auth-worker)
